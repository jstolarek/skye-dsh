{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE TemplateHaskell      #-}
{-# LANGUAGE TypeFamilies         #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE ViewPatterns         #-}

{-# LANGUAGE MonadComprehensions #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE RebindableSyntax    #-}

-- | This module is another prototype approach to where-provenance.  Instead on
-- relying on where-provenance being constructed using the meta-data attached to
-- table declareation, we construct it explicitly with a query.
module Schema.PPDP2016ToursProv2 where

import           Database.DSH
import           Database.DSH.Provenance

import           Schema.PPDP2016Tours

data AgencyP = AgencyP
    { p_id       :: Integer
    , p_name     :: Text
    , p_based_in :: Text
    , p_phone    :: WhereProv Text
    } deriving (Show)

-- This omits generation of smart constructor and table selectors - these will
-- be different in the presence of where-provenance annotations.
deriveQA   ''AgencyP
deriveTA   ''AgencyP
deriveView ''AgencyP

-- JSTOLAREK: prototype code below.  In the final version of library all these
-- code needs to be generated with TH

-- This query constructs a list of agencies with provenance information added to
-- phone field.
agenciesP :: Q [AgencyP]
agenciesP =
    [ agencyP_prov (a_idQ a) (a_nameQ a) (a_based_inQ a)
                   (tup2 (a_phoneQ a)
                         (just $ whereProvData (toQ "agencies")
                                               (toQ "a_phone" ) (a_idQ a)))
    | a <- agencies ]

-- Smart constructor generates empty provenance information.  Obviously, the
-- data is not pulled from the database.
agencyP :: Q Integer -> Q Text -> Q Text -> Q Text -> Q AgencyP
agencyP (Q e_a8D1) (Q e_a8D2) (Q e_a8D3) e_a8D4
  = Q (TupleConstE (Tuple4E e_a8D1 e_a8D2 e_a8D3 (unQ . emptyProvQ $ e_a8D4)))

-- But we might also want to reconstruct an agency with some known provenance
agencyP_prov :: Q Integer -> Q Text -> Q Text -> Q (WhereProv Text) -> Q AgencyP
agencyP_prov (Q e_a8D1) (Q e_a8D2) (Q e_a8D3) (Q e_a8D4)
  = Q (TupleConstE (Tuple4E e_a8D1 e_a8D2 e_a8D3 e_a8D4))

-- An open question is what functions to generate if we have more than one field
-- with provenance tracking?  I would say that there should be two constructors
-- at most: one without provenance information and another with all possible
-- provenance information.  Then we can either discard where-provenance
-- information or add empty provenance to a value.

-- Code below should be generated by generateTableSelectors
p_idQ :: Q AgencyP -> Q Integer
p_idQ (view -> (x_aap2, _, _, _)) = x_aap2
p_nameQ :: Q AgencyP -> Q Text
p_nameQ (view -> (_, x_aap3, _, _)) = x_aap3
p_based_inQ :: Q AgencyP -> Q Text
p_based_inQ (view -> (_, _, x_aap4, _)) = x_aap4

-- A field with provenance gets three selectors instead of one.  Forst selector
-- simply returns the field with attached provenance information.  Code is the
-- same as with a normal selector but type of the selector is different.  The
-- remaining two selector are projections of data and provenance components
-- respectively
p_phoneQ :: Q AgencyP -> Q (WhereProv Text)
p_phoneQ (view -> (_, _, _, x_aap5)) = x_aap5
p_phone_dataQ :: Q AgencyP -> Q Text
p_phone_dataQ (view -> (_, _, _, x_aap5)) = dataQ x_aap5
p_phone_provQ :: Q AgencyP -> Q WhereProvInfo
p_phone_provQ (view -> (_, _, _, x_aap5)) = provQ x_aap5
