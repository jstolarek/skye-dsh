Scratchpad
==========

Below are random notes that have not yet went into documentation.  Mostly
exceprts from emails with Alex Ulrich.

Regarding Q22 in test-tpch taking too long to run:

> use 'showBackendCodeQ optBU naturalPgCodeGen q22Default' to check it out

> (2) Modify your PostgreSQL configuration to allow more memory being
> used. Most relevant are the shared_buffers and work_mem parameters. The
> default settings are overly conservative.

### DSH compilation pipeline

> The compiler is structured as a series of lowerings from subsequent
> intermediate representations:
>
> 1. Frontend.Internals: Typed expressions as generated by the DSH
> frontend. These are translated into CL (Translate.Frontend2CL)
> 2. CL.Lang (Comprehension Language): A first-order intermediate
> representation with proper comprehensions. Mostly used for optimization.
> Desugared into NKL (Translate.CL2NKL).
> 3. NKL.Lang (Nested Kernel Language): IR with simple iterators instead
> of comprehensions. Input for the flattening transformation
> (Translate.NKL2FKL).
> 4. FKL.Lang (Flat Kernel Language): IR without iterators/comprehensions
> but data-parallel primitives instead. Translated into SL (Translate.FKL2SL)
> 5. SL.Lang (Segment Language): Algebraic language, basically implements
> Blelloch's segment vector model. Translated into relational algebra and
> then to SQL in dsh-sql.


TODO
----

  * Figure out how function application works in DSH.  Can I use lambdas?  If I
    call my own functions what constructs can they contain?  What happens if
    they call functions unsupported by DSH?

  * It seems that `QA` and `TA` classes overlap.  If I create a record type that
    stores a nested tuple, can I store it in a database?

  * Figure out how to use PostgreSQL OID fields to assign initial
    where-provenance row id
