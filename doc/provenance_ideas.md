Ideas on extending DSH with provenance tracking
===============================================

Where-provenance representation
-------------------------------

Where-provenance could be tracked with a triple `(String, String, Integer)`
standing for table name, column name and row id.  Probably a better idea would
be to define `Provenance` record with three records and then write `QA` instance
for it.  I'm not sure if the `View` instance will be necessary - see later.

Now I could mark provenance tracking by introducing `Prov` at the type level
like this:

```haskell
data Agency = Agency
    { a_id       :: Integer
    , a_name     :: Prov Text
    , a_based_in :: Text
    , a_phone    :: Text
    } deriving (Show)
```

The purpose of `Prov` would be to simply detect its presence during TH
transformations and generate extra provenance information for a field which type
is `Prov sth`.  Note that TH can't tell whether `Prov` is a type family, type
constructor or type synonym - it only sees a type application.

It is not yet clear to me what `Prov` should be.  One idea is to have it as an
identity type family defined for base types only (those types that allow
provenance tracking):

```haskell
type family Prop a where
     Prop Text    = Text
     Prop Integer = Integer
     Prop Bool    = Bool
```

Another approach would be to define `Prov` as a type synonym:

```haskell
type Prov a = (a, String, String, Integer)
```

This avoids the problem of making a logical connection between provenance
information and the data that it refers to (see discussion of `QA` instances
below).  This would definitely require a slightly different treatment of view
patterns and field accessors generated with them.  Also, making class instances
of a type synonym will require an extra language extension.

Perhaps using data families is also an option here?

**Note:** where-provenance might be absent, for example in situations when a
  value is generated by the query.  In such case provenance is bottom (`_|_`).
  This suggests that provenance will likely have to be represented using a
  `Maybe`, e.g.:

```haskell
type family Prop a where
     Prop Text    = ( Text   , Maybe Provenance )
     Prop Integer = ( Integer, Maybe Provenance )
     Prop Bool    = ( Bool   , Maybe Provenance )
```

**Note:** no matter what representation I pick I should make it abstract to
  prevent programmer from creating values of that type (cf. "Language-integrated
  provenance", Section 3.1).


Where-provenance encoding
-------------------------

Assuming the type family approach a rough idea is:

  - in the `QA` instance generate extra tuple fields in `Rep` instance.
    Hopefully extra tuple field like `Rep Provenance` will be permitted.  So in
    the above example I would get:

    ```haskell
    instance QA Agency where
      type Rep Agency = ( Rep Integer, Rep Text, Rep (Maybe Provenance)
                        , Rep Text   , Rep Text
                        )
    ```

    It is not clear to me how to connect provenance to a particular field.
    (Quote from paper, sec. 3.1: _"Provenance information has meaning only in
    the context of data it belongs to."_) In the example above I placed the
    provenance info right after a field it is assigned to but that seems very
    fragile, more of a hack than a proper solution.  More on this later.

    Generating appropriate definitions of `toExp`/`fromExp` should be
    straightforward.

  - I think `View` instance should take provenance into account.  This will
    later be used by `generateTableSelectors` to generate selectors that allow
    to read provenance.  So in the example above we would have:

    ```haskell
    a_nameQ :: Q Agency -> Q Text
    a_nameQ (view -> (_, name, _, _, _)) = name

    prov_a_nameQ :: Q Agency -> Q Provenance
    prov_a_nameQ (view -> (_, _, prov, _)) = prov
    ```

  - It is not yet clear to me how adding provenance would affect the table
    schema.  I believe this is the dilemma of having eager vs. lazy provenance.
    In the eager case the table schema would have to contain information about
    provenance columns.  One solution would be to do this completely explicitly,
    ie. require programmer to list and name provenance columns.  Another
    approach would be to create a simple function to automatically generate
    provenance columns.  So for example:

    ```haskell
    agencies :: Q [Agency]
    agencies = table "agencies"
                   ( "a_id" :|
                     prov "a_name" ++
                   [ "a_based_in"
                   , "a_phone"
                   ])
                   (TableHints (pure $ Key (pure "a_id") ) NonEmpty)
    ```

    where `prov a_name` would return `["a_name", "a_name_prov_table",
    "a_name_prov_column", "a_name_prov_row"]`.  However, such encoding does not
    seem to allow provenance to be bottom.  I suppose it is technically possible
    to insert `null` into provenance columns if provenance is missing and have
    that converted into `Nothing`, but that seems like a lot of hassle.

    **NOTE:** The above might be wrong.  The table is flat, but internal
      representation of provenance will most likely be nested.  This would
      probably required explicit treatment and conversion inside DSH.  Perhaps
      it would be possible to extend `TableHints` to contain extra information
      necessary to do this?

    Perhaps a proper approach would be to have a separate table for provenance
    and have connections between tables?

    Reading the papers on provenance in Links makes me believe that in the
    simplest setting provenance might not have to be stored in a database, so
    modification of table schema will not be necessary.  Section 3.1 of
    "Language-integrated provenance" gives details of the provenance encoding in
    Links and describes how a provenance-extended table is created on the fly.

That more or less covers the treatment of provenance on the surface.  I do not
yet have any idea how to handle provenance under the hood, especially the fact
that it must be tracked implicitly.


Some open questions and loose thoughts
--------------------------------------

  * Should I add provenance to internal type language?  My guess is this would
    simplify (or perhaps even enable?) handling of provenance under the hood.
    Still it is not clear to me how to make a connection between provenance
    information and the field it is supposed to be assigned to.  (Quote from
    paper: _"The type system should capture the special nature of provenance
    meta-data."_)

    BTW. Does the DSH's internal type system have any typing rules written down
    somewhere?  I should probably ask Alex.

  * Directly connected to the previous question is the problem of propagating
    provenance implicitly under the hood.  Two things how to do this come to my
    mind:

      - Handle provenance tracking during comprehension desugaring.  I'm not
        sure if this would be a good idea.  I think that desugaring should only
        insert information that provenance is supposed to be tracked but without
        assigning any semantic meaning.  In other words desugaring should only
        do desugaring.

      - Handle provenance during translation to CL.  `translate` function would
        convert provenance annotations into concrete query constructs.  This
        means that `CL` and any subsequent internal representation (NKL, FKL,
        SL) would not have to be modified.

    **Note:** _this paragraph is here for historical reasons.  I got confused a
    bit and want to record this confusion for now, hopefully to avoid it in the
    future_.  Note that the ideas above seem to be slightly different than in
    "Language-integrated provenance in Links" paper.  In the paper user is
    allowed to define a function that says how to compute provenance.  Above I
    assumed that the system will internally track provenance.  For example, if
    data is copied into a record field (database cell) the system will fill in
    the required provenance information.  However, this might be hard to
    achieve.  Most importantly, how will the system know where does data
    originate from?  While this seems easy to track when copying data directly
    from a database table, it seems a lot harder when data is produced by some
    intermediate query.  To handle such a situation we would need to thread
    provenance through all the intermediate queries.  Moreover, we will either
    have to figure out how to determine which components of the intermediate
    query need to have provenance attached, or eagerly attach provenance to
    every component of intermediate query just in case this information is
    needed at the end.  The second alternative might be to costly in terms of
    overhead.

    "Language-integrated query" paper, section 3.1 clarifies how
    where-provenance is propagated.  The idea is that by default provenance
    information is attached to a particular field and propagated together with
    value of that field.  However, users are allowed to define their own
    functions that compute provenance.  The intended use case is to fetch
    provenance metadata stored separately from the actual data.  This is
    probably something worth having in the final system, but at the moment I
    don't have a good idea how to incorporate this into my encoding.

  * The consequence of proposed representation is that provenance could only be
    inspected (via generated table selectors) but not modified in any way.
    Also, perhaps it would make sense to generate a separate type class for
    viewing provenance?  I'm not sure if this has any merit but the thought
    crossed my mind at one point so I'm noting it down.

  * One thing to keep in mind is that DSH assumes maximum tuple width to be 16.
    So it would be possible to attach provenance to at most 8 fields.  That's
    not a theoretical problem but could potentially limit practical
    applications.  Of course it is trivially simple to modify DSH to allow wider
    tuples but, as usual with TH, performance might drop.

  * It should be possible to use DSH's internal type information to guide basic
    provenance transformations.  However, I doubt this approach will work for
    some complex transformations.  I fear that using type information provided
    in the AST will sooner or later require a full implementation of type
    checking and inference algorithm.  Needless to say, this will be far from
    trivial.

  * The above discussion concentrates on where-provenance.  But what about other
    forms of provenance?  Can they be expressed using this approach?  It would
    be nice to come up with something that allows extension to other forms of
    provenance and a uniform treatment of all of them.


Some notes on "Language-integrated Provenance in Links" paper
-------------------------------------------------------------

### Section 3.1 - Type system

Four requirements for a type system that tracks provenance:

  - **"provenance is attached to data and automatically propagated"**

    Still need to figure out how to do this - see earlier discussion.

  - **"type system should prevent accidental modification [of provenance]"**

    I think this will be prevented by the surface encoding.  There will only be
    a view that allows to extract provenance from internal representation.  This
    should allow to write queries that inspect provenance - cf. example in the
    paper in Figure 2, where comment provenance is queried.  Another thing to do
    is to ensure encapsulation of provenance abstractions.  This should be
    easily done using Haskell modules.

  - **"changes to data would invalidate where-provenance"**

    I think this is closely related to (1).  This definitely needs to be
    implemented explicitly in the query translation.

  - **"it is not possible for a programmer to forge provenance"**

    Loosely related to (2).  I fear the proposed approach might be susceptible
    to provenance forgery in a quite simple way.  Programmer could write a data
    type that explicitly contains provenance as one of the fields.  In this way
    provenance would become available for modification in the surface language.
    And since internal representation of such a data type would be identical to
    data type with implicit provenance, it could be used to forge provenance.
    Moreover, queries over this data type would be compatible with the database
    schema.  It seems that the only hope here is that `table` declarations have
    an assigned type.  Then again, programmer can write a new `table`
    declaration that works with forged data type.  OTOH, is that really a
    problem?  If a programmer has full access to the database they can do
    literally anything with it.

In the paper provenance can only be attached to base types.  In my proposal this
would be achieved by defining `Prov` as a closed type family with instances only
for those types for which we can track provenance.


### Section 3.2 - Translation

There are two things I don't understand in this section.  Firstly, in general
where-provenance might be absent if a value was generated by a query and not
copied from another table.  (This problem does not arise with the example in the
paper but in general it is possible.)  How would such a situation be represented
by proposed encoding?  Secondly, the paper does not seem to say how to compute
provenance.  It assumes that all the provenance information is somehow magically
present in `top_comments` table and then just shuffles it around.


Some notes on "Language-integrated Provenance" paper
----------------------------------------------------

### Section 1 - Introduction

_"no prior work considers the interaction of provenance with clients of the
database"_ - WAT?  As in "nobody ever implemented these ideas"?


### Section 2.4 - Where-provenance and lineage

Attaching `prov` annotation to a table field adds extra provenance information
to that field: table and column name (these are the same for all entries) and id
of corresponding row.  This is rather simple.  I think the biggest difficulty
here is assigning id number based on database row.  However, in this system
provenance data is managed explicitly.  For example:

```
var q1''' = query {
  for (a <-- agencies)
    for (e <-- externalTours)
    where (a.name == e.name && e.type == "boat")
      [(name = e.name,
        phone = data a.phone, p_phone = prov a.phone)]
}
```

Here provenance is managed explicitly.  I was thinking that provenance should be
handled implicitly:

```
var q1''' = query {
  for (a <-- agencies)
    for (e <-- externalTours)
    where (a.name == e.name && e.type == "boat")
      [(name = e.name, phone = a.phone)]
}
```

Here, since `phone` field is annotated with provenance information, provenance
would be implicitly assigned to `phone` field in the result.  Of course if we
wanted to inspect provenance then we would still have to extract it explicitly.


### Section 3.1 - Where-provenance
