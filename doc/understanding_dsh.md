Understanding DSH
=================

Below are notes on my attempts to understand how DSH works.  My analysis is
based on reading DSH source code and a case study of an example query from
"Language-integrated Provenance" paper.


DSH internals
-------------

### Encoding expressions

DSH uses GADTs to define its internal expression language.  Its AST is
represented by `Exp` data type in `Database.DSH.Frontend.Internals` module.
Leaves of the `Exp` tree store concrete values, e.g.:

```haskell
data Exp a where
    UnitE       :: Exp ()
    BoolE       :: !Bool    -> Exp Bool
--  (...)
    AppE        :: (Reify a, Reify b)  => Fun a b -> Exp a -> Exp b
    TupleConstE :: !(TupleConst a) -> Exp a
```

Applications are represented by `AppE` using `Fun` GADT from
`Database.DSH.Frontend.Builtins`.  It encodes all database allowed functions
together with their types, e.g:

```haskell
data Fun a b where
    Not     :: Fun Bool Bool
    Concat  :: Fun [[a]] [a]
    Null    :: Fun [a] Bool
    TupElem :: TupElem a b -> Fun a b
```


#### Encoding tuples

The last constructor, `TupElem`, encodes a tuple accessor.  `TupElem` is a GADT
encoding all the tuple accessors (generated by `mkTupElemType` in
`Database.DSH.Frontend.TupleTypes`):

```haskell
data TupElem a b where
    Tup2_1 :: TupElem (a, b) a
    Tup2_2 :: TupElem (a, b) b
    Tup3_1 :: TupElem (a, b, c) a
    Tup3_2 :: TupElem (a, b, c) b
    Tup3_3 :: TupElem (a, b, c) c
```

`TupleConstE` constructor of `Exp` data type represents tuples using
`TupleConst` (generated by `mkTupleAstComponents` in
`Database.DSH.Frontend.TupleTypes`):

```haskell
data TupleConst a where
    Tuple<n>E :: (Reify t1, ..., Reify t<n>) => Exp t1
                                             -> ...
                                             -> Exp t<n>
                                             -> TupleConst (t1, ..., t<n>)
```

There are also other helper functions, eg. `tup2` generated by
`mkTupleConstructors` (`tup2` is used later in the case study):

```haskell
tups :: (QA t1, QA t2) => Q t1 -> Q t2 -> Q (t1, t2)
tup2 (Q v1) (Q v2)= Q (TupleConstE (Tuple2E v1 vn))
```


### Encoding types

There's also `Type` GADT that represents types of expressions encoded with
`Exp` values:

```haskell
data Type a where
    UnitT  :: Type ()
    BoolT  :: Type Bool
--  (...)
    ArrowT :: (Reify a,Reify b)  => Type a -> Type b -> Type (a -> b)
    TupleT :: TupleType a -> Type a
```

`TupleType` is analogous to `TupleConst`, except that constructors store `Type`
values rather than `Exp` values.


### Type classes & friends

DSH also defines several type classes in `Database.DSH.Frontend.TupleTypes`


#### Reify

```haskell
class Reify a where
    reify :: a -> Type a
```

Allows to convert expressions into type of their embedding.  For example:

```haskell
instance Reify Bool where
    reify _ = BoolT
```

Which means that `reify true` will return `BoolT`.


#### QA

```haskell
class (Reify (Rep a)) => QA a where
    type Rep a
    toExp :: a -> Exp (Rep a)
    frExp :: Exp (Rep a) -> a
```

`QA` represents types that can be represented using DSH's expression language
(`Exp` data type).  `Rep a` represents a (Haskell, non-embedded) type used to
encode the internal representation of a data type.  For most basic types this is
an identity function (`Bool` is represented by a `Bool`, `()` by a `()` and so
on), but there are some exceptions, eg. `type Rep (Maybe a) = [Rep a]`.
`toExp`/`fromExp` convert Haskell expressions to DSH's expression
representation.  Note the `Reify (Rep a)` constraint on `QA` ensures that
representation type must be reifiable.


#### TA

```haskell
class TA a where
```

This class represents elements that can be represented in a flat relational
table row.  There are `TA` instances for `()`, `Bool`, `Char`, `Integer`,
`Double`, `Text`, `Decimal`, `Scientific`, `Day`, and tuples (generated with TH)
in `Database.DSH.Frontend.Externals`, but there is no instance for lists.  `TA`
constraint is crucially used on the signature of `table`:

```haskell
table :: (QA a, TA a) => String -> [...] -> Q [a]
```


#### Q newtype

```haskell
newtype Q a = Q (Exp (Rep a))
```

Just a wrapper around `Exp`.  Ensures that internal representation uses `Rep`
type.


#### View

```haskell
class View a where
    type ToView a
    view :: a -> ToView a
```

Ensures a view exists for a given type.  This is later used with view patterns
generated by `generateTableSelectors`.  Instances are generated for types
wrapped in `Q`.  It seems that structure of `ToView a` is identical to `Rep a`,
except that recursion happens in `Q` rather than in `Rep`.


### Table declarations

DSH's expression language contains representation for database tables:

```haskell
data Exp a where
--  (...)
    TableE      :: (Reify a)           => Table -> Exp [a]
--  (...)

data Table = TableDB String (NonEmpty ColName) TableHints

data TableHints = TableHints
    { keysHint     :: NonEmpty Key
    , nonEmptyHint :: Emptiness
    } deriving (Eq, Ord, Show)
```

`nonEmptyHint` hints whether a table might be empty or is known not to be empty.
`keysHint` gives "a combination of column names that form a candidate key",
where `Key` is a non-empty list of strings:

```haskell
newtype Key = Key (NonEmpty String)
```

`table` function from `Database.DSH.Frontend.Externals` is essentially a smart
constructor for table expressions:

```haskell
table :: (QA a, TA a) => String -> NonEmpty ColName -> TableHints -> Q [a]
table name schema hints = Q (TableE (TableDB name schema hints))
```

Interesting thing about it is that return type does not depend in any way on the
arguments.  In other words, type of table declaration is essential to determine
what kind of data is actually stored in a table.


### Compilation pipeline

At a high level pipeline looks like this:

```haskell
execQ :: (QA a, Show a) => BackendConn PgVector -> Q a -> IO ()
execQ c q = runQ naturalPgCodeGen c q >>= print

runQ :: forall a b v. (VectorLang v, BackendVector b, QA a)
     => BackendCodeGen v b
     -> BackendConn b
     -> Q a
     -> IO a
runQ codeGen conn (Q q) = do
    let ty = reify (undefined :: Rep a)
    let comprehensions = toComprehensions q
    let vectorPlan = compileOptQ optBU comprehensions
    let backendCode = codeGen vectorPlan
    frExp <$> execQueryBundle conn backendCode ty

compileOptQ :: VectorLang v => CLOptimizer -> CL.Expr -> QueryPlan v DVec
compileOptQ clOpt = compileQ clOpt >>> optimizeVectorPlan

compileQ :: VectorLang v => CLOptimizer -> CL.Expr -> QueryPlan v DVec
compileQ clOpt = (fst . clOpt) >>>
                 desugarComprehensions  >>>
                 optimizeNKL            >>>
                 flatTransform          >>>
                 vectorize
```


### Query desugaring

GHC desugars a comprehension into calls to `>>=` and `return`.  DSH uses
`RebindableSyntax` to ensure that these desugarings refer to `>>=`, `return` and
other functions defined in `Database.DSH.Frontend.Externals` module.  That
module also redefines many functions from standard Prelude to work on DSH
expressions wrapped in `Q`.  For example:

```haskell
return :: (QA a) => Q a -> Q [a]
return = singleton

(>>=) :: (QA a,QA b) => Q [a] -> (Q a -> Q [b]) -> Q [b]
(>>=) ma f = concatMap f ma

concatMap :: (QA a,QA b) => (Q a -> Q [b]) -> Q [a] -> Q [b]
concatMap f (Q as) = Q (AppE ConcatMap (pairE (LamE (toLam f)) as))
```

So the result of desugaring is a series of calls to functions that construct
DSH's `Exp` values.


### Comprehension language (CL)

Comprehension language is the next intermediate representation used by DSH in
its pipeline.  CL is explicitly typed.  Translation from expression language to
comprehension language is performed by `translate` function in
`Database.DSH.Translate.Frontend2CL` module.

#### Expressions

```haskell
data Expr  = Table   Type String BaseTableSchema
           | AppE1   Type Prim1 Expr
           | AppE2   Type Prim2 Expr Expr
           | BinOp   Type ScalarBinOp Expr Expr
           | UnOp    Type ScalarUnOp Expr
           | If      Type Expr Expr Expr
           | Lit     Type Val
           | Var     Type Ident
           | Comp    Type Expr (NL Qual)
           | MkTuple Type [Expr]
           | Let     Type Ident Expr Expr

data Prim1 = Singleton | Only   | Concat | Null  | Reverse
           | Nub       | Number | Sort   | Group | Guard
           | TupElem TupleIndex | Agg AggrFun

data Prim2 = Append | Zip | CartProduct
           | ThetaJoin (JoinPredicate ScalarExpr)
           | NestJoin  (JoinPredicate ScalarExpr)
           | GroupJoin (JoinPredicate ScalarExpr) (NE AggrApp)
           | SemiJoin  (JoinPredicate ScalarExpr)
           | AntiJoin  (JoinPredicate ScalarExpr)

data AggrFun = Length | Avg | Minimum | Maximum | And | Or | Sum
```

One important thing worth noting is that aggregation in CL is denoted explicitly
using dedicated AST data type.


#### Types

```haskell
data Type  = ListT Type
           | TupleT [Type]
           | ScalarT ScalarType

data ScalarType  = IntT | BoolT | DoubleT | StringT | UnitT | DecimalT | DateT
```


#### Translation from frontend language to CL

The most interesting part of `translate` is translation of function application,
which is in fact delegated to `translateApp`.  Here are some example of handling
translation from `Exp` to `CL.Expr` by `translateApp` (module code cleanup and
abbreviation - actual source code is minimally different):

```haskell
translateApp ConcatMap (Tuple2E (LamE lam) xs) = do
    xs'                 <- translate xs
    (boundVar, bodyExp) <- lamBody lam
    bodyExp'            <- translate bodyExp
    return $ CP.concat $ CP.singleGenComp bodyExp' boundVar xs'
translateApp Minimum   args = CP.minimum <$> translate args
```

where `concat`, `minimum` and `singleGenComp` is defined as:

```haskell
concat :: Expr -> Expr
concat e = let t = typeOf e
           in if listDepth t P.> 1
              then AppE1 (unliftType t) Concat e
              else tyErr "concat"

minimum :: Expr -> Expr
minimum e = let (ListT t) = typeOf e
            in if isNum t
               then AppE1 t (Agg Minimum) e
               else tyErr "minimum"

singleGenComp :: Expr -> LIdent -> Expr -> Expr
singleGenComp bodyExp v gen =
    let bodyTy = typeOf bodyExp
    in Comp (ListT bodyTy) bodyExp (S $ BindQ v gen)
```

Note that `minimum` inserts explicit aggregation operator and also propagates
the type of aggregated expression.


#### Translation of table declarations into CL

It seems to me that the crucial bit to implementing provenance is modifying the
translation of table declarations.  The initial representation in the frontend
language is translated into `BaseTableSchema` data type defined in
`Database.DSH.Common.Lang`:

```haskell
data BaseTableSchema = BaseTableSchema
    { tableCols     :: N.NonEmpty ColumnInfo
    , tableKeys     :: N.NonEmpty Key
    , tableNonEmpty :: Emptiness
    } deriving (Eq, Ord, Show)
```

Here's how translation is done in `Database.DSH.Translate.Frontend2CL`:

```haskell
translate (TableE (TableDB tableName colNames hints)) = do
    -- Reify the type of the table expression
    let ty = reify (undefined :: a)            -- (1)
    let colNames' = fmap L.ColName colNames
    let bty = translateType ty                 -- (2)

    return $ CP.table bty tableName (schema tableName colNames' bty hints)

schema :: String -> N.NonEmpty L.ColName -> Ty.Type -> TableHints -> L.BaseTableSchema
schema tableName cols ty hints =
    L.BaseTableSchema { L.tableCols     = colTys
                      , L.tableKeys     = keys (keysHint hints)
                      , L.tableNonEmpty = ne $ nonEmptyHint hints
                      }
  where
    colTys :: NonEmpty L.ColumnInfo
    colTys = case Ty.elemT ty of
        Ty.TupleT ts@(_:_) | length ts == N.length cols ->
            case mapM Ty.scalarType ts of    -- (3)
                Just (st : sts) -> N.zip cols (st :| sts)
                _               -> error errMsgScalar
        (Ty.ScalarT st)      | N.length cols == 1       ->
            N.zip cols (st :| [])
        _                                              ->
            error errMsgLen
```

There are three important bits in this code:

  - **reify type of table expression** - `a` is a type of table expression in
    the source program.  This should be a list of some data types.  For example,
    in the case study below this will be `[Agency]`.  `Rep` of this actual type
    is reified to obtain type's frontend representation.

  - **translate type of table into CL representation** - frontend type is
    translated into internal `Type` defined in `Database.DSH.Common.Type`.

    ```haskell
    data Type = ListT Type | TupleT [Type] | ScalarT ScalarType
              deriving (Show, Eq, Ord)

    data ScalarType = IntT | BoolT | DoubleT | StringT | UnitT | DecimalT | DateT
                    deriving (Show, Eq, Ord)
    ```

    This representation is used throughout the remaining parts of the
    compilation pipeline.

  - **check that table stores scalar (flat) data** - `Ty.elemT` assumes its
    argument is a `ListT` and returns the type of elements in a list.  Then
    `mapM Ty.scalarType ts` will return a list of scalar types stored in
    components of a tuple (records representing table rows are internally stored
    as tuples).  Note that if at least one field is not a scalar type then the
    whole expression will return a `Nothing`, resulting in compilation error.


Case study
----------

Below is a simple case study of a an example query from "Language-integrated
Provenance" paper.  All the TH code below was obtained by building the project
using `cabal build --ghc-options=-ddump-splices` and cleaning up the results
slightly.


### Table row representation and derived definitions

To represent a single table row one needs to define a record type which
structure corresponds to table schema:

```haskell
data Agency = Agency
    { a_id       :: Integer
    , a_name     :: Text
    , a_based_in :: Text
    , a_phone    :: Text
    } deriving (Show)

deriveDSH              ''Agency
deriveTA               ''Agency
generateTableSelectors ''Agency
```

`Text` is a data type from `Data.Text`, that is re-exported by `Database.DSH`.
`deriveDSH`, `deriveTA` and `generateTableSelectors` are defined in
`Database.DSH.Frontend.TH`.


#### deriveDSH ''Agency

```haskell
instance QA Agency where
  type Rep Agency = (Rep Integer, Rep Text, Rep Text, Rep Text)
  toExp (Agency id name based_in phone)
    = TupleConstE (Tuple4E (toExp id) (toExp name) (toExp based_in)
                           (toExp phone))
  frExp (TupleConstE (Tuple4E id name based_in phone))
    = Agency (frExp id) (frExp name) (frExp based_in) (frExp phone)
  frExp _ = error "DSH: Impossible happened at ..."

instance View (Q Agency) where
  type ToView (Q Agency) = (Q Integer, Q Text, Q Text, Q Text)
  view (Q agency)
    = ((Q $ (AppE (TupElem Tup4_1) agency)),
       (Q $ (AppE (TupElem Tup4_2) agency)),
       (Q $ (AppE (TupElem Tup4_3) agency)),
       (Q $ (AppE (TupElem Tup4_4) agency)))

agency :: Q Integer -> Q Text -> Q Text -> Q Text -> Q Agency
agency (Q id) (Q name) (Q based_in) (Q phone)
  = Q (TupleConstE (Tuple4E id name based_in phone))
```

**QA instance**: record of basic types is represented as a tuple.  `Tuple4E` is
  a constructor of `TupleConst` and stores four `Exp` values.  `TupleConstE` is
  a data constructor of `Exp`.  `toExp`/`fromExp` are pretty straightforward.

**View instance**: this is slightly less intuitive, so let's break it down into
  smaller pieces.  By definition of `Q` and `Rep Agency` we get that `Q Agency`
  is `Q (Exp (Integer, Text, Text, Text))`.  So for this instance type of
  `view`is:

```haskell
view :: Q (Exp (Integer, Text, Text, Text)) -> (Q Integer, Q Text, Q Text, Q Text)
```

Remember that, by definition of `Q`, `Q Integer` and `Q Text` stand for `Exp
Integer` and `Exp Text`.  Here are the types of other expressions used in the
definition of `view`:

```haskell
Tup4_1  :: TupElem (a,b,c,d) d
TupElem :: TupElem (a,b,c,d) d -> Fun (a,b,c,d) d
agency  :: Exp (Integer, Text, Text, Text)
AppE    :: Fun a b -> Exp a -> Exp b
```


#### deriveTA ''Agency

```haskell
instance TA Agency
```


#### generateTableSelectors ''Agency

```haskell
a_idQ :: Q Agency -> Q Integer
a_idQ (view -> (id, _, _, _)) = id

a_nameQ :: Q Agency -> Q Text
a_nameQ (view -> (_, name, _, _)) = name

a_based_inQ :: Q Agency -> Q Text
a_based_inQ (view -> (_, _, based_in, _)) = based_in

a_phoneQ :: Q Agency -> Q Text
a_phoneQ (view -> (_, _, _, phone)) = phone
```

These are accessors to all fields of `Agency` defined within `Q` newtype.  These
can be used directly in the queries.


### Table schema

```haskell
agencies :: Q [Agency]
agencies = table "agencies"
                 ( "a_id" :|
                 [ "a_name"
                 , "a_based_in"
                 , "a_phone"
                 ])
                 (TableHints (pure $ Key (pure "a_id") ) NonEmpty)
```

`pure` refers to `Applicative` instance for `NonEmpty` data type. `:|` is a
constructor of `NonEmpty` list.


Query desugaring
----------------

```haskell
-- | Query from Figure 1
q1 :: Q [(Text, Text)]
q1 = [ tup2 (et_nameQ et) (a_phoneQ a)
     | a  <- agencies
     , et <- externalTours
     , a_nameQ a  == et_nameQ et
     , et_typeQ et == "boat"
     ]
```

I believe that the most important bit required to implement where-provenance is
understanding how `a <- agencies` is executed.  Why?  Because this is the bit
that extracts data from the database table and we want that extracted data to
contain provenance information, although the information itself is not present
in the database.  Let's trace how desugaring and compilation happens for this
expression:

```haskell
-- original form
a <- agencies
body

-- desugaring of do-notation
agencies >>= (\a -> body)

-- DSH frontend desugaring
concatMap (\a -> body) agencies

-- call to concatMap produces
Q (AppE ConctaMap (pairE (LamE (toLam (\a -> body))) agencies))
-- where
agencies = (TableE (TableDB "agencies" col_names hints))
pairE a b = TupleConstE (Tuple2E a b)
toLam :: (QA a,QA b) => (Q a -> Q b) -> Exp (Rep a) -> Exp (Rep b)
toLam f = unQ . f . Q
```


Query compilation to SQL
------------------------

`toComprehensions` is called to translate from frontend language to CL language.
Continuing the previous example:

```haskell
-- application AppE is translated by translateApp to:
AppE1 _ Concat (Comp (ListT ..) body
                     (S $ BindQ a (Table (TupleT [...]) "agencies" schema)))
-- where
S - singleton list constructor
BindQ - stores a String (`a`) and a table expression
```

Generated query
---------------

For the above example generated SQL query is:

```SQL
SELECT a0.a_id AS o1, a1.et_id AS o2, a1.et_name AS i1, a0.a_phone AS i2
FROM agencies AS a0, externaltours AS a1
WHERE (a0.a_name = a1.et_name) AND (a1.et_type = 'boat')
ORDER BY o1 ASC, o2 ASC
```

`ORDER BY` is how DSH maintains list semantics.
